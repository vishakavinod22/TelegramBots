


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > BaseAbilityBot</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.telegram.abilitybots.api.bot</a>
</div>

<h1>Coverage Summary for Class: BaseAbilityBot (org.telegram.abilitybots.api.bot)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">BaseAbilityBot</td>
<td class="coverageStat">
  <span class="percent">
    83.8%
  </span>
  <span class="absValue">
    (57/68)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.4%
  </span>
  <span class="absValue">
    (216/256)
  </span>
</td>
</tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$3JgIW6CX</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$3nVgK44g</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$4RauDjFG</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$7sKChNV8</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$7SN4cVdG</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$7UKKlxaL</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$80veViGm</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$8JGqNiRn</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$8Psg4S7z</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$9RQdAMbD</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$9ZGyzyPz</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$aQVAX9tA</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$Av4nV4xX</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$biYUy13q</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$c2no1WEA</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$c6KigGqw</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$CFXhISbO</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$CS2BaQ0L</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$Ctcxezfe</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$ePHj9Ve5</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$EQn0o1Km</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$FRQm59fF</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$gGEANzO0</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$gnpyWrGf</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$GR4zhSSS</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$GRB8Ej1P</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$gt3Xo8Ki</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$h1aP6eT9</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$H7KH1PdM</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$IS4wIoXr</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$j1JQ5pA1</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$jfxYlRZz</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$jJT058Yf</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$JMlwElYT</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$KRNr09kT</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$LflSxRVi</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$lGguLFOz</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$lkyZFr77</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$LlI4wRGb</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$Lt1qPL0j</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$LxUOoPGD</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$MG6zOaVi</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$mkRpvv30</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$MQmpJAvJ</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$naMUeMW5</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$OlQf1DDD</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$orI9wVV6</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$Pblpk2kP</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$Qv3BrcyK</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$QwQJQmA6</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$RDEkUhnD</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$RTWFNhDd</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$S6UAmHsH</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$sKxHRKn8</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$sQc5ctXP</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$T0V7Tekh</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$teDyzJI3</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$terMtpMw</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$TvFDuHtn</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$uUGtOiGq</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$v3dASCar</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$VnUmRsi7</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$W3eLPkqp</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$wmTRGYUW</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$wUCOGfRc</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$x2rvJmwN</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$yZ1ozXun</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$yzVC6leQ</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$zM0Y51p6</td>
  </tr>
  <tr>
    <td class="name">BaseAbilityBot$MockitoMock$TSevJREu$auxiliary$zwAiyvVK</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    83.8%
  </span>
  <span class="absValue">
    (57/68)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.4%
  </span>
  <span class="absValue">
    (216/256)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package org.telegram.abilitybots.api.bot;
&nbsp;
&nbsp;import com.google.common.collect.ImmutableList;
&nbsp;import com.google.common.collect.ImmutableList.Builder;
&nbsp;import com.google.common.collect.ImmutableMap;
&nbsp;import org.slf4j.Logger;
&nbsp;import org.slf4j.LoggerFactory;
&nbsp;import org.telegram.abilitybots.api.db.DBContext;
&nbsp;import org.telegram.abilitybots.api.objects.Ability;
&nbsp;import org.telegram.abilitybots.api.objects.Locality;
&nbsp;import org.telegram.abilitybots.api.objects.MessageContext;
&nbsp;import org.telegram.abilitybots.api.objects.Privacy;
&nbsp;import org.telegram.abilitybots.api.objects.Reply;
&nbsp;import org.telegram.abilitybots.api.objects.ReplyCollection;
&nbsp;import org.telegram.abilitybots.api.objects.Stats;
&nbsp;import org.telegram.abilitybots.api.sender.DefaultSender;
&nbsp;import org.telegram.abilitybots.api.sender.MessageSender;
&nbsp;import org.telegram.abilitybots.api.sender.SilentSender;
&nbsp;import org.telegram.abilitybots.api.toggle.AbilityToggle;
&nbsp;import org.telegram.abilitybots.api.util.AbilityExtension;
&nbsp;import org.telegram.abilitybots.api.util.AbilityUtils;
&nbsp;import org.telegram.abilitybots.api.util.Pair;
&nbsp;import org.telegram.abilitybots.api.util.Trio;
&nbsp;import org.telegram.telegrambots.bots.DefaultAbsSender;
&nbsp;import org.telegram.telegrambots.bots.DefaultBotOptions;
&nbsp;import org.telegram.telegrambots.meta.api.methods.groupadministration.GetChatAdministrators;
&nbsp;import org.telegram.telegrambots.meta.api.objects.Message;
&nbsp;import org.telegram.telegrambots.meta.api.objects.Update;
&nbsp;import org.telegram.telegrambots.meta.api.objects.User;
&nbsp;import org.telegram.telegrambots.meta.api.objects.chatmember.ChatMemberAdministrator;
&nbsp;import org.telegram.telegrambots.meta.api.objects.chatmember.ChatMemberOwner;
&nbsp;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.Callable;
&nbsp;import java.util.function.BiFunction;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;import static com.google.common.collect.Sets.difference;
&nbsp;import static java.lang.String.format;
&nbsp;import static java.time.ZonedDateTime.now;
&nbsp;import static java.util.Arrays.stream;
&nbsp;import static java.util.Comparator.comparingInt;
&nbsp;import static java.util.Objects.isNull;
&nbsp;import static java.util.Optional.ofNullable;
&nbsp;import static java.util.regex.Pattern.CASE_INSENSITIVE;
&nbsp;import static java.util.regex.Pattern.compile;
&nbsp;import static java.util.stream.Collectors.toSet;
&nbsp;import static org.telegram.abilitybots.api.objects.Locality.ALL;
&nbsp;import static org.telegram.abilitybots.api.objects.Locality.GROUP;
&nbsp;import static org.telegram.abilitybots.api.objects.Locality.USER;
&nbsp;import static org.telegram.abilitybots.api.objects.MessageContext.newContext;
&nbsp;import static org.telegram.abilitybots.api.objects.Privacy.ADMIN;
&nbsp;import static org.telegram.abilitybots.api.objects.Privacy.CREATOR;
&nbsp;import static org.telegram.abilitybots.api.objects.Privacy.GROUP_ADMIN;
&nbsp;import static org.telegram.abilitybots.api.objects.Privacy.PUBLIC;
&nbsp;import static org.telegram.abilitybots.api.objects.Stats.createStats;
&nbsp;import static org.telegram.abilitybots.api.util.AbilityMessageCodes.CHECK_INPUT_FAIL;
&nbsp;import static org.telegram.abilitybots.api.util.AbilityMessageCodes.CHECK_LOCALITY_FAIL;
&nbsp;import static org.telegram.abilitybots.api.util.AbilityMessageCodes.CHECK_PRIVACY_FAIL;
&nbsp;import static org.telegram.abilitybots.api.util.AbilityUtils.EMPTY_USER;
&nbsp;import static org.telegram.abilitybots.api.util.AbilityUtils.getChatId;
&nbsp;import static org.telegram.abilitybots.api.util.AbilityUtils.getLocalizedMessage;
&nbsp;import static org.telegram.abilitybots.api.util.AbilityUtils.getUser;
&nbsp;import static org.telegram.abilitybots.api.util.AbilityUtils.isGroupUpdate;
&nbsp;import static org.telegram.abilitybots.api.util.AbilityUtils.isSuperGroupUpdate;
&nbsp;import static org.telegram.abilitybots.api.util.AbilityUtils.isUserMessage;
&nbsp;
&nbsp;/**
&nbsp; * The &lt;b&gt;father&lt;/b&gt; of all ability bots. Bots that need to utilize abilities need to extend this bot.
&nbsp; * &lt;p&gt;
&nbsp; * It&#39;s important to note that this bot strictly extends {@link DefaultAbsSender}.
&nbsp; * &lt;p&gt;
&nbsp; * All bots extending the {@link BaseAbilityBot} get implicit abilities:
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;/claim - Claims this bot&lt;/li&gt;
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;Sets the user as the {@link Privacy#CREATOR} of the bot&lt;/li&gt;
&nbsp; * &lt;li&gt;Only the user with the ID returned by {@link BaseAbilityBot#creatorId()} can genuinely claim the bot&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * &lt;li&gt;/report - reports all user-defined commands (abilities)&lt;/li&gt;
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;The same format acceptable by BotFather&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * &lt;li&gt;/commands - returns a list of all possible bot commands based on the privacy of the requesting user&lt;/li&gt;
&nbsp; * &lt;li&gt;/backup - returns a backup of the bot database&lt;/li&gt;
&nbsp; * &lt;li&gt;/recover - recovers the database&lt;/li&gt;
&nbsp; * &lt;li&gt;/promote &lt;code&gt;@username&lt;/code&gt; - promotes user to bot admin&lt;/li&gt;
&nbsp; * &lt;li&gt;/demote &lt;code&gt;@username&lt;/code&gt; - demotes bot admin to user&lt;/li&gt;
&nbsp; * &lt;li&gt;/ban &lt;code&gt;@username&lt;/code&gt; - bans the user from accessing your bot commands and features&lt;/li&gt;
&nbsp; * &lt;li&gt;/unban &lt;code&gt;@username&lt;/code&gt; - lifts the ban from the user&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Additional information of the implicit abilities are present in the methods that declare them.
&nbsp; * &lt;p&gt;
&nbsp; * The two most important handles in the BaseAbilityBot are the {@link DBContext} &lt;b&gt;&lt;code&gt;db&lt;/code&gt;&lt;/b&gt; and the {@link MessageSender} &lt;b&gt;&lt;code&gt;sender&lt;/code&gt;&lt;/b&gt;.
&nbsp; * All bots extending BaseAbilityBot can use both handles in their update consumers.
&nbsp; *
&nbsp; * @author Abbas Abou Daya
&nbsp; */
&nbsp;@SuppressWarnings({&quot;UnusedReturnValue&quot;, &quot;WeakerAccess&quot;, &quot;unused&quot;, &quot;ConstantConditions&quot;})
&nbsp;public abstract class BaseAbilityBot extends DefaultAbsSender implements AbilityExtension {
<b class="fc">&nbsp;    private static final Logger log = LoggerFactory.getLogger(BaseAbilityBot.class);</b>
&nbsp;
&nbsp;    protected static final String DEFAULT = &quot;default&quot;;
&nbsp;    // DB objects
&nbsp;    public static final String ADMINS = &quot;ADMINS&quot;;
&nbsp;    public static final String USERS = &quot;USERS&quot;;
&nbsp;    public static final String USER_ID = &quot;USER_ID&quot;;
&nbsp;    public static final String BLACKLIST = &quot;BLACKLIST&quot;;
&nbsp;    public static final String STATS = &quot;ABILITYBOT_STATS&quot;;
&nbsp;
&nbsp;    // DB and sender
&nbsp;    protected final DBContext db;
&nbsp;    protected MessageSender sender;
&nbsp;    protected SilentSender silent;
&nbsp;
&nbsp;    // Ability toggle
&nbsp;    private final AbilityToggle toggle;
&nbsp;
&nbsp;    // Bot username
&nbsp;    private final String botUsername;
&nbsp;
&nbsp;    // Ability registry
<b class="fc">&nbsp;    private final List&lt;AbilityExtension&gt; extensions = new ArrayList&lt;&gt;();</b>
&nbsp;    private Map&lt;String, Ability&gt; abilities;
&nbsp;    private Map&lt;String, Stats&gt; stats;
&nbsp;
&nbsp;    // Reply registry
&nbsp;    private List&lt;Reply&gt; replies;
&nbsp;
&nbsp;    public abstract long creatorId();
&nbsp;
&nbsp;    protected BaseAbilityBot(String botToken, String botUsername, DBContext db, AbilityToggle toggle, DefaultBotOptions botOptions) {
<b class="fc">&nbsp;        super(botOptions, botToken);</b>
&nbsp;
<b class="fc">&nbsp;        this.botUsername = botUsername;</b>
<b class="fc">&nbsp;        this.db = db;</b>
<b class="fc">&nbsp;        this.toggle = toggle;</b>
<b class="fc">&nbsp;        this.sender = new DefaultSender(this);</b>
<b class="fc">&nbsp;        silent = new SilentSender(sender);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void onRegister() {
<b class="fc">&nbsp;        registerAbilities();</b>
<b class="fc">&nbsp;        initStats();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return the database of this bot
&nbsp;     */
&nbsp;    public DBContext db() {
<b class="nc">&nbsp;        return db;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return the message sender for this bot
&nbsp;     */
&nbsp;    public MessageSender sender() {
<b class="nc">&nbsp;        return sender;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return the silent sender for this bot
&nbsp;     */
&nbsp;    public SilentSender silent() {
<b class="nc">&nbsp;        return silent;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return the map of &lt;ID,User&gt;
&nbsp;     */
&nbsp;    public Map&lt;Long, User&gt; users() {
<b class="fc">&nbsp;        return db.getMap(USERS);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return the map of &lt;Username,ID&gt;
&nbsp;     */
&nbsp;    public Map&lt;String, Long&gt; userIds() {
<b class="fc">&nbsp;        return db.getMap(USER_ID);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return a blacklist containing all the IDs of the banned users
&nbsp;     */
&nbsp;    public Set&lt;Long&gt; blacklist() {
<b class="fc">&nbsp;        return db.getSet(BLACKLIST);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return an admin set of all the IDs of bot administrators
&nbsp;     */
&nbsp;    public Set&lt;Long&gt; admins() {
<b class="fc">&nbsp;        return db.getSet(ADMINS);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return a mapping of ability and reply names to their corresponding statistics
&nbsp;     */
&nbsp;    public Map&lt;String, Stats&gt; stats() {
<b class="fc">&nbsp;        return stats;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return the immutable map of &lt;String,Ability&gt;
&nbsp;     */
&nbsp;    public Map&lt;String, Ability&gt; abilities() {
<b class="fc">&nbsp;        return abilities;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @return the immutable list carrying the embedded replies
&nbsp;     */
&nbsp;    public List&lt;Reply&gt; replies() {
<b class="nc">&nbsp;        return replies;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * This method contains the stream of actions that are applied on any update.
&nbsp;     * &lt;p&gt;
&nbsp;     * It will correctly handle addition of users into the DB and the execution of abilities and replies.
&nbsp;     *
&nbsp;     * @param update the update received by Telegram&#39;s API
&nbsp;     */
&nbsp;    public void onUpdateReceived(Update update) {
<b class="fc">&nbsp;        log.info(format(&quot;[%s] New update [%s] received at %s&quot;, botUsername, update.getUpdateId(), now()));</b>
<b class="fc">&nbsp;        log.info(update.toString());</b>
<b class="fc">&nbsp;        long millisStarted = System.currentTimeMillis();</b>
&nbsp;
<b class="fc">&nbsp;        Stream.of(update)</b>
<b class="fc">&nbsp;                .filter(this::checkGlobalFlags)</b>
<b class="fc">&nbsp;                .filter(this::checkBlacklist)</b>
<b class="fc">&nbsp;                .map(this::addUser)</b>
<b class="fc">&nbsp;                .filter(this::filterReply)</b>
<b class="fc">&nbsp;                .filter(this::hasUser)</b>
<b class="fc">&nbsp;                .map(this::getAbility)</b>
<b class="fc">&nbsp;                .filter(this::validateAbility)</b>
<b class="fc">&nbsp;                .filter(this::checkPrivacy)</b>
<b class="fc">&nbsp;                .filter(this::checkLocality)</b>
<b class="fc">&nbsp;                .filter(this::checkInput)</b>
<b class="fc">&nbsp;                .filter(this::checkMessageFlags)</b>
<b class="fc">&nbsp;                .map(this::getContext)</b>
<b class="fc">&nbsp;                .map(this::consumeUpdate)</b>
<b class="fc">&nbsp;                .map(this::updateStats)</b>
<b class="fc">&nbsp;                .forEach(this::postConsumption);</b>
&nbsp;
&nbsp;        // Commit to DB now after all the actions have been dealt
<b class="fc">&nbsp;        db.commit();</b>
&nbsp;
<b class="fc">&nbsp;        long processingTime = System.currentTimeMillis() - millisStarted;</b>
<b class="fc">&nbsp;        log.info(format(&quot;[%s] Processing of update [%s] ended at %s%n---&gt; Processing time: [%d ms] &lt;---%n&quot;, botUsername, update.getUpdateId(), now(), processingTime));</b>
&nbsp;    }
&nbsp;
&nbsp;    public String getBotUsername() {
<b class="nc">&nbsp;        return botUsername;</b>
&nbsp;    }
&nbsp;
&nbsp;    public Privacy getPrivacy(Update update, long id) {
<b class="fc">&nbsp;        return isCreator(id) ?</b>
<b class="fc">&nbsp;            CREATOR : isAdmin(id) ?</b>
<b class="nc">&nbsp;            ADMIN : (isGroupUpdate(update) || isSuperGroupUpdate(update)) &amp;&amp; isGroupAdmin(update, id) ?</b>
<b class="fc">&nbsp;            GROUP_ADMIN : PUBLIC;</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isGroupAdmin(Update update, long id) {
<b class="fc">&nbsp;        return isGroupAdmin(getChatId(update), id);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isGroupAdmin(long chatId, long id) {
<b class="fc">&nbsp;        GetChatAdministrators admins = GetChatAdministrators.builder().chatId(chatId).build();</b>
<b class="fc">&nbsp;        return silent.execute(admins)</b>
<b class="fc">&nbsp;                .orElse(new ArrayList&lt;&gt;())</b>
<b class="fc">&nbsp;                .stream()</b>
<b class="fc">&nbsp;                .map(member -&gt; {</b>
<b class="fc">&nbsp;                    final String status = member.getStatus();</b>
<b class="fc">&nbsp;                    if (status.equals(ChatMemberOwner.STATUS)</b>
<b class="fc">&nbsp;                            || status.equals(ChatMemberAdministrator.STATUS)) {</b>
<b class="fc">&nbsp;                        return member.getUser().getId();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return 0L;</b>
&nbsp;                })
<b class="fc">&nbsp;                .anyMatch(member -&gt; member == id);</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isCreator(long id) {
<b class="fc">&nbsp;        return id == creatorId();</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isAdmin(long id) {
<b class="fc">&nbsp;        return admins().contains(id);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Test the update against the provided global flags. The default implementation is a passthrough to all updates.
&nbsp;     * &lt;p&gt;
&nbsp;     * This method should be &lt;b&gt;overridden&lt;/b&gt; if the user wants to restrict bot usage to only certain updates.
&nbsp;     *
&nbsp;     * @param update a Telegram {@link Update}
&nbsp;     * @return &lt;tt&gt;true&lt;/tt&gt; if the update satisfies the global flags
&nbsp;     */
&nbsp;    protected boolean checkGlobalFlags(Update update) {
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected String getCommandPrefix() {
<b class="fc">&nbsp;        return &quot;/&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected String getCommandRegexSplit() {
<b class="fc">&nbsp;        return &quot; &quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected boolean allowContinuousText() {
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void addExtension(AbilityExtension extension) {
<b class="nc">&nbsp;        this.extensions.add(extension);</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void addExtensions(AbilityExtension... extensions) {
<b class="nc">&nbsp;        this.extensions.addAll(Arrays.asList(extensions));</b>
&nbsp;    }
&nbsp;
&nbsp;    protected void addExtensions(Collection&lt;AbilityExtension&gt; extensions) {
<b class="nc">&nbsp;        this.extensions.addAll(extensions);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Registers the declared abilities using method reflection. Also, replies are accumulated using the built abilities and standalone methods that return a Reply.
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Only abilities and replies with the &lt;u&gt;public&lt;/u&gt; accessor are registered!&lt;/b&gt;
&nbsp;     */
&nbsp;    private void registerAbilities() {
&nbsp;        try {
&nbsp;            // Collect all classes that implement AbilityExtension declared in the bot
<b class="fc">&nbsp;            extensions.addAll(stream(getClass().getMethods())</b>
<b class="fc">&nbsp;                    .filter(checkReturnType(AbilityExtension.class))</b>
<b class="fc">&nbsp;                    .map(returnExtension(this))</b>
<b class="fc">&nbsp;                    .collect(Collectors.toList()));</b>
&nbsp;
&nbsp;            // Add the bot itself as it is an AbilityExtension
<b class="fc">&nbsp;            extensions.add(this);</b>
&nbsp;
<b class="fc">&nbsp;            DefaultAbilities defaultAbs = new DefaultAbilities(this);</b>
<b class="fc">&nbsp;            Stream&lt;Ability&gt; defaultAbsStream = stream(DefaultAbilities.class.getMethods())</b>
<b class="fc">&nbsp;                .filter(checkReturnType(Ability.class))</b>
<b class="fc">&nbsp;                .map(returnAbility(defaultAbs))</b>
<b class="fc">&nbsp;                .filter(ab -&gt; !toggle.isOff(ab))</b>
<b class="fc">&nbsp;                .map(toggle::processAbility);</b>
&nbsp;
&nbsp;            // Extract all abilities from every single extension instance
<b class="fc">&nbsp;            abilities = Stream.concat(defaultAbsStream,</b>
<b class="fc">&nbsp;                extensions.stream()</b>
<b class="fc">&nbsp;                    .flatMap(ext -&gt; stream(ext.getClass().getMethods())</b>
<b class="fc">&nbsp;                            .filter(checkReturnType(Ability.class))</b>
<b class="fc">&nbsp;                            .map(returnAbility(ext))))</b>
&nbsp;                    // Abilities are immutable, build it respectively
<b class="fc">&nbsp;                    .collect(ImmutableMap::&lt;String, Ability&gt;builder,</b>
<b class="fc">&nbsp;                            (b, a) -&gt; b.put(a.name(), a),</b>
<b class="nc">&nbsp;                            (b1, b2) -&gt; b1.putAll(b2.build()))</b>
<b class="fc">&nbsp;                    .build();</b>
&nbsp;
&nbsp;            // Extract all replies from every single extension instance
<b class="fc">&nbsp;            Stream&lt;Reply&gt; extensionReplies = extensions.stream()</b>
<b class="fc">&nbsp;                    .flatMap(ext -&gt; stream(ext.getClass().getMethods())</b>
<b class="fc">&nbsp;                            .filter(checkReturnType(Reply.class))</b>
<b class="fc">&nbsp;                            .map(returnReply(ext)))</b>
<b class="fc">&nbsp;                            .flatMap(Reply::stream);</b>
&nbsp;
&nbsp;            // Extract all replies from extension instances methods, returning ReplyCollection
<b class="fc">&nbsp;            Stream&lt;Reply&gt; extensionCollectionReplies = extensions.stream()</b>
<b class="fc">&nbsp;                    .flatMap(extension -&gt; stream(extension.getClass().getMethods())</b>
<b class="fc">&nbsp;                            .filter(checkReturnType(ReplyCollection.class))</b>
<b class="fc">&nbsp;                            .map(returnReplyCollection(extension))</b>
<b class="fc">&nbsp;                            .flatMap(ReplyCollection::stream));</b>
&nbsp;
&nbsp;            // Replies can be standalone or attached to abilities, fetch those too
<b class="fc">&nbsp;            Stream&lt;Reply&gt; abilityReplies = abilities.values().stream()</b>
<b class="fc">&nbsp;                    .flatMap(ability -&gt; ability.replies().stream())</b>
<b class="fc">&nbsp;                    .flatMap(Reply::stream);</b>
&nbsp;
&nbsp;            // Now create the replies registry (list)
<b class="fc">&nbsp;            replies = Stream.of(abilityReplies, extensionReplies, extensionCollectionReplies)</b>
<b class="fc">&nbsp;                    .flatMap(replyStream -&gt; replyStream)</b>
<b class="fc">&nbsp;                    .collect(</b>
&nbsp;                            ImmutableList::&lt;Reply&gt;builder,
&nbsp;                            Builder::add,
<b class="nc">&nbsp;                            (b1, b2) -&gt; b1.addAll(b2.build()))</b>
<b class="fc">&nbsp;                    .build();</b>
<b class="nc">&nbsp;        } catch (IllegalStateException e) {</b>
<b class="nc">&nbsp;            log.error(&quot;Duplicate names found while registering abilities. Make sure that the abilities declared don&#39;t clash with the reserved ones.&quot;, e);</b>
<b class="nc">&nbsp;            throw new RuntimeException(e);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    private void initStats() {
<b class="fc">&nbsp;        Set&lt;String&gt; enabledStats = Stream.concat(</b>
<b class="fc">&nbsp;            replies.stream().filter(Reply::statsEnabled).map(Reply::name),</b>
<b class="fc">&nbsp;            abilities.entrySet().stream()</b>
<b class="fc">&nbsp;                .filter(entry -&gt; entry.getValue().statsEnabled())</b>
<b class="fc">&nbsp;                .map(Map.Entry::getKey)).collect(toSet());</b>
<b class="fc">&nbsp;        stats = db.getMap(STATS);</b>
<b class="fc">&nbsp;        Set&lt;String&gt; toBeRemoved = difference(stats.keySet(), enabledStats);</b>
<b class="fc">&nbsp;        toBeRemoved.forEach(stats::remove);</b>
<b class="fc">&nbsp;        enabledStats.forEach(abName -&gt; stats.computeIfAbsent(abName,</b>
<b class="fc">&nbsp;            name -&gt; createStats(abName, 0)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * @param clazz the type to be tested
&nbsp;     * @return a predicate testing the return type of the method corresponding to the class parameter
&nbsp;     */
&nbsp;    private static Predicate&lt;Method&gt; checkReturnType(Class&lt;?&gt; clazz) {
<b class="fc">&nbsp;        return method -&gt; clazz.isAssignableFrom(method.getReturnType());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the method and retrieves its return {@link Reply}.
&nbsp;     *
&nbsp;     * @param obj a bot or extension that this method is invoked with
&nbsp;     * @return a {@link Function} which returns the {@link Reply} returned by the given method
&nbsp;     */
&nbsp;    private Function&lt;? super Method, AbilityExtension&gt; returnExtension(Object obj) {
<b class="fc">&nbsp;        return method -&gt; {</b>
&nbsp;            try {
<b class="nc">&nbsp;                return (AbilityExtension) method.invoke(obj);</b>
<b class="nc">&nbsp;            } catch (IllegalAccessException | InvocationTargetException e) {</b>
<b class="nc">&nbsp;                log.error(&quot;Could not add ability extension&quot;, e);</b>
<b class="nc">&nbsp;                throw new RuntimeException(e);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the method and retrieves its return {@link Ability}.
&nbsp;     *
&nbsp;     * @param obj a bot or extension that this method is invoked with
&nbsp;     * @return a {@link Function} which returns the {@link Ability} returned by the given method
&nbsp;     */
&nbsp;    private static Function&lt;? super Method, Ability&gt; returnAbility(Object obj) {
<b class="fc">&nbsp;        return method -&gt; {</b>
&nbsp;            try {
<b class="fc">&nbsp;                return (Ability) method.invoke(obj);</b>
<b class="nc">&nbsp;            } catch (IllegalAccessException | InvocationTargetException e) {</b>
<b class="nc">&nbsp;                log.error(&quot;Could not add ability&quot;, e);</b>
<b class="nc">&nbsp;                throw new RuntimeException(e);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the method and retrieves its return {@link Reply}.
&nbsp;     *
&nbsp;     * @param obj a bot or extension that this method is invoked with
&nbsp;     * @return a {@link Function} which returns the {@link Reply} returned by the given method
&nbsp;     */
&nbsp;    private static Function&lt;? super Method, Reply&gt; returnReply(Object obj) {
<b class="fc">&nbsp;        return method -&gt; {</b>
&nbsp;            try {
<b class="fc">&nbsp;                return (Reply) method.invoke(obj);</b>
<b class="nc">&nbsp;            } catch (IllegalAccessException | InvocationTargetException e) {</b>
<b class="nc">&nbsp;                log.error(&quot;Could not add reply&quot;, e);</b>
<b class="nc">&nbsp;                throw new RuntimeException(e);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the method and retrieves its return {@link ReplyCollection}.
&nbsp;     *
&nbsp;     * @param obj a bot or extension that this method is invoked with
&nbsp;     * @return a {@link Function} which returns the {@link ReplyCollection} returned by the given method
&nbsp;     */
&nbsp;    private static Function&lt;? super Method, ReplyCollection&gt; returnReplyCollection(Object obj) {
<b class="fc">&nbsp;        return method -&gt; {</b>
&nbsp;            try {
<b class="fc">&nbsp;                return (ReplyCollection) method.invoke(obj);</b>
<b class="nc">&nbsp;            } catch (IllegalAccessException | InvocationTargetException e) {</b>
<b class="nc">&nbsp;                log.error(&quot;Could not add Reply Collection&quot;, e);</b>
<b class="nc">&nbsp;                throw new RuntimeException(e);</b>
&nbsp;            }
&nbsp;        };
&nbsp;    }
&nbsp;
&nbsp;    private void postConsumption(Pair&lt;MessageContext, Ability&gt; pair) {
<b class="fc">&nbsp;        ofNullable(pair.b().postAction())</b>
<b class="fc">&nbsp;                .ifPresent(consumer -&gt; consumer.accept(pair.a()));</b>
&nbsp;    }
&nbsp;
&nbsp;    Pair&lt;MessageContext, Ability&gt; consumeUpdate(Pair&lt;MessageContext, Ability&gt; pair) {
<b class="fc">&nbsp;        pair.b().action().accept(pair.a());</b>
<b class="fc">&nbsp;        return pair;</b>
&nbsp;    }
&nbsp;
&nbsp;    Pair&lt;MessageContext, Ability&gt; updateStats(Pair&lt;MessageContext, Ability&gt; pair) {
<b class="fc">&nbsp;        Ability ab = pair.b();</b>
<b class="fc">&nbsp;        if (ab.statsEnabled()) {</b>
<b class="fc">&nbsp;            updateStats(pair.b().name());</b>
&nbsp;        }
<b class="fc">&nbsp;        return pair;</b>
&nbsp;    }
&nbsp;
&nbsp;    private void updateReplyStats(Reply reply) {
<b class="fc">&nbsp;        if (reply.statsEnabled()) {</b>
<b class="fc">&nbsp;            updateStats(reply.name());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    void updateStats(String name) {
<b class="fc">&nbsp;        Stats statsObj = stats.get(name);</b>
<b class="fc">&nbsp;        statsObj.hit();</b>
<b class="fc">&nbsp;        stats.put(name, statsObj);</b>
&nbsp;    }
&nbsp;
&nbsp;    Pair&lt;MessageContext, Ability&gt; getContext(Trio&lt;Update, Ability, String[]&gt; trio) {
<b class="fc">&nbsp;        Update update = trio.a();</b>
<b class="fc">&nbsp;        User user = AbilityUtils.getUser(update);</b>
&nbsp;
<b class="fc">&nbsp;        return Pair.of(newContext(update, user, getChatId(update), this, trio.c()), trio.b());</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean checkBlacklist(Update update) {
<b class="fc">&nbsp;        User user = getUser(update);</b>
<b class="fc">&nbsp;        if (isNull(user)) {</b>
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        long id = user.getId();</b>
<b class="fc">&nbsp;        return id == creatorId() || !blacklist().contains(id);</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean checkInput(Trio&lt;Update, Ability, String[]&gt; trio) {
<b class="fc">&nbsp;        String[] tokens = trio.c();</b>
<b class="fc">&nbsp;        int abilityTokens = trio.b().tokens();</b>
&nbsp;
<b class="fc">&nbsp;        boolean isOk = abilityTokens == 0 || (tokens.length &gt; 0 &amp;&amp; tokens.length == abilityTokens);</b>
&nbsp;
<b class="fc">&nbsp;        if (!isOk)</b>
<b class="fc">&nbsp;            silent.send(</b>
<b class="fc">&nbsp;                    getLocalizedMessage(</b>
&nbsp;                            CHECK_INPUT_FAIL,
<b class="fc">&nbsp;                            AbilityUtils.getUser(trio.a()).getLanguageCode(),</b>
<b class="fc">&nbsp;                            abilityTokens, abilityTokens == 1 ? &quot;input&quot; : &quot;inputs&quot;),</b>
<b class="fc">&nbsp;                    getChatId(trio.a()));</b>
<b class="fc">&nbsp;        return isOk;</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean checkLocality(Trio&lt;Update, Ability, String[]&gt; trio) {
<b class="fc">&nbsp;        Update update = trio.a();</b>
<b class="fc">&nbsp;        Locality locality = isUserMessage(update) ? USER : GROUP;</b>
<b class="fc">&nbsp;        Locality abilityLocality = trio.b().locality();</b>
&nbsp;
<b class="fc">&nbsp;        boolean isOk = abilityLocality == ALL || locality == abilityLocality;</b>
&nbsp;
<b class="fc">&nbsp;        if (!isOk)</b>
<b class="fc">&nbsp;            silent.send(</b>
<b class="fc">&nbsp;                    getLocalizedMessage(</b>
&nbsp;                            CHECK_LOCALITY_FAIL,
<b class="fc">&nbsp;                            AbilityUtils.getUser(trio.a()).getLanguageCode(),</b>
<b class="fc">&nbsp;                            abilityLocality.toString().toLowerCase()),</b>
<b class="fc">&nbsp;                    getChatId(trio.a()));</b>
<b class="fc">&nbsp;        return isOk;</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean checkPrivacy(Trio&lt;Update, Ability, String[]&gt; trio) {
<b class="fc">&nbsp;        Update update = trio.a();</b>
<b class="fc">&nbsp;        User user = AbilityUtils.getUser(update);</b>
&nbsp;        Privacy privacy;
<b class="fc">&nbsp;        long id = user.getId();</b>
&nbsp;
<b class="fc">&nbsp;        privacy = getPrivacy(update, id);</b>
&nbsp;
<b class="fc">&nbsp;        boolean isOk = privacy.compareTo(trio.b().privacy()) &gt;= 0;</b>
&nbsp;
<b class="fc">&nbsp;        if (!isOk)</b>
<b class="fc">&nbsp;            silent.send(</b>
<b class="fc">&nbsp;                    getLocalizedMessage(</b>
&nbsp;                            CHECK_PRIVACY_FAIL,
<b class="fc">&nbsp;                            AbilityUtils.getUser(trio.a()).getLanguageCode()),</b>
<b class="fc">&nbsp;                    getChatId(trio.a()));</b>
<b class="fc">&nbsp;        return isOk;</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean validateAbility(Trio&lt;Update, Ability, String[]&gt; trio) {
<b class="fc">&nbsp;        return trio.b() != null;</b>
&nbsp;    }
&nbsp;
&nbsp;    Trio&lt;Update, Ability, String[]&gt; getAbility(Update update) {
&nbsp;        // Handle updates without messages
&nbsp;        // Passing through this function means that the global flags have passed
<b class="fc">&nbsp;        Message msg = update.getMessage();</b>
<b class="fc">&nbsp;        if (!update.hasMessage() || !msg.hasText())</b>
<b class="fc">&nbsp;            return Trio.of(update, abilities.get(DEFAULT), new String[]{});</b>
&nbsp;
&nbsp;        Ability ability;
&nbsp;        String[] tokens;
<b class="fc">&nbsp;        if (allowContinuousText()) {</b>
<b class="nc">&nbsp;            String abName = abilities.keySet().stream()</b>
<b class="nc">&nbsp;                .filter(name -&gt; msg.getText().startsWith(format(&quot;%s%s&quot;, getCommandPrefix(), name)))</b>
<b class="nc">&nbsp;                .max(comparingInt(String::length))</b>
<b class="nc">&nbsp;                .orElse(DEFAULT);</b>
<b class="nc">&nbsp;            tokens = msg.getText()</b>
<b class="nc">&nbsp;                .replaceFirst(getCommandPrefix() + abName, &quot;&quot;)</b>
<b class="nc">&nbsp;                .split(getCommandRegexSplit());</b>
<b class="nc">&nbsp;            ability = abilities.get(abName);</b>
<b class="nc">&nbsp;        } else {</b>
<b class="fc">&nbsp;            tokens = msg.getText().split(getCommandRegexSplit());</b>
<b class="fc">&nbsp;            if (tokens[0].startsWith(getCommandPrefix())) {</b>
<b class="fc">&nbsp;                String abilityToken = stripBotUsername(tokens[0].substring(1)).toLowerCase();</b>
<b class="fc">&nbsp;                ability = abilities.get(abilityToken);</b>
<b class="fc">&nbsp;                tokens = Arrays.copyOfRange(tokens, 1, tokens.length);</b>
<b class="fc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                ability = abilities.get(DEFAULT);</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return Trio.of(update, ability, tokens);</b>
&nbsp;    }
&nbsp;
&nbsp;    private String stripBotUsername(String token) {
<b class="fc">&nbsp;        return compile(format(&quot;@%s&quot;, botUsername), CASE_INSENSITIVE)</b>
<b class="fc">&nbsp;                .matcher(token)</b>
<b class="fc">&nbsp;                .replaceAll(&quot;&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    Update addUser(Update update) {
<b class="fc">&nbsp;        User endUser = AbilityUtils.getUser(update);</b>
<b class="fc">&nbsp;        if (endUser.equals(EMPTY_USER)) {</b>
&nbsp;            // Can&#39;t add an empty user, return the update as is
<b class="fc">&nbsp;            return update;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        users().compute(endUser.getId(), (id, user) -&gt; {</b>
<b class="fc">&nbsp;            if (user == null) {</b>
<b class="fc">&nbsp;                updateUserId(user, endUser);</b>
<b class="fc">&nbsp;                return endUser;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (!user.equals(endUser)) {</b>
<b class="fc">&nbsp;                updateUserId(user, endUser);</b>
<b class="fc">&nbsp;                return endUser;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            return user;</b>
&nbsp;        });
&nbsp;
<b class="fc">&nbsp;        return update;</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean hasUser(Update update) {
&nbsp;        // Valid updates without users should return an empty user
&nbsp;        // Updates that are not recognized by the getUser method will throw an exception
<b class="fc">&nbsp;        return !AbilityUtils.getUser(update).equals(EMPTY_USER);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void updateUserId(User oldUser, User newUser) {
<b class="fc">&nbsp;        if (oldUser != null &amp;&amp; oldUser.getUserName() != null) {</b>
&nbsp;            // Remove old username -&gt; ID
<b class="fc">&nbsp;            userIds().remove(oldUser.getUserName());</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (newUser.getUserName() != null) {</b>
&nbsp;            // Add new mapping with the new username
<b class="fc">&nbsp;            userIds().put(newUser.getUserName().toLowerCase(), newUser.getId());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    boolean filterReply(Update update) {
<b class="fc">&nbsp;        return replies.stream()</b>
<b class="fc">&nbsp;                .filter(reply -&gt; runSilently(() -&gt; reply.isOkFor(update), reply.name()))</b>
<b class="fc">&nbsp;                .map(reply -&gt; runSilently(() -&gt; {</b>
<b class="fc">&nbsp;                    reply.actOn(this, update);</b>
<b class="fc">&nbsp;                    updateReplyStats(reply);</b>
<b class="fc">&nbsp;                    return false;</b>
<b class="fc">&nbsp;                }, reply.name()))</b>
<b class="fc">&nbsp;                .reduce(true, Boolean::logicalAnd);</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean runSilently(Callable&lt;Boolean&gt; callable, String name) {
&nbsp;        try {
<b class="fc">&nbsp;            return callable.call();</b>
<b class="fc">&nbsp;        } catch(Exception ex) {</b>
<b class="fc">&nbsp;            String msg = format(&quot;Reply [%s] failed to check for conditions. &quot; +</b>
&nbsp;                    &quot;Make sure you&#39;re safeguarding against all possible updates.&quot;, name);
<b class="fc">&nbsp;            if (log.isDebugEnabled()) {</b>
<b class="nc">&nbsp;                log.error(msg, ex);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                log.error(msg);</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    boolean checkMessageFlags(Trio&lt;Update, Ability, String[]&gt; trio) {
<b class="fc">&nbsp;        Ability ability = trio.b();</b>
<b class="fc">&nbsp;        Update update = trio.a();</b>
&nbsp;
&nbsp;        // The following variable is required to avoid bug #JDK-8044546
<b class="fc">&nbsp;        BiFunction&lt;Boolean, Predicate&lt;Update&gt;, Boolean&gt; flagAnd = (flag, nextFlag) -&gt; flag &amp;&amp; nextFlag.test(update);</b>
<b class="fc">&nbsp;        return ability.flags().stream()</b>
<b class="fc">&nbsp;                .reduce(true, flagAnd, Boolean::logicalAnd);</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-10-29 13:12</div>
</div>
</body>
</html>
